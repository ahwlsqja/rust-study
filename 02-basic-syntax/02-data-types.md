# 데이터 타입

## 개요

Rust는 **정적 타입(statically typed)** 언어로, 컴파일 시점에 모든 변수의 타입이 결정되어야 한다. Rust의 데이터 타입은 크게 **스칼라 타입**과 **복합 타입**으로 나뉜다.

---

## 이론

### 타입 시스템 개요

```
┌─────────────────────────────────────────────────────────────┐
│  Rust 데이터 타입 분류                                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   데이터 타입                                               │
│   ├── 스칼라 타입 (단일 값)                                 │
│   │   ├── 정수 (i8, i16, i32, i64, i128, isize)            │
│   │   │       (u8, u16, u32, u64, u128, usize)             │
│   │   ├── 부동소수점 (f32, f64)                            │
│   │   ├── 불리언 (bool)                                    │
│   │   └── 문자 (char)                                      │
│   │                                                         │
│   └── 복합 타입 (여러 값을 하나로)                          │
│       ├── 튜플 (tuple)                                     │
│       └── 배열 (array)                                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 스칼라 타입

#### 1. 정수 타입 (Integer)

```
┌─────────────────────────────────────────────────────────────┐
│  정수 타입 일람표                                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   부호 있음 (signed)     부호 없음 (unsigned)               │
│   ┌────────────────┐    ┌────────────────┐                 │
│   │ i8   : -128 ~ 127    │ u8  : 0 ~ 255                   │
│   │ i16  : -32768 ~      │ u16 : 0 ~ 65535                 │
│   │ i32  : -21억 ~       │ u32 : 0 ~ 42억        (기본)    │
│   │ i64  : 매우 큼       │ u64 : 매우 큼                   │
│   │ i128 : 엄청 큼       │ u128: 엄청 큼                   │
│   │ isize: 아키텍처 의존 │ usize: 아키텍처 의존            │
│   └────────────────┘    └────────────────┘                 │
│                                                             │
│   비트 수 계산:                                             │
│   - 8비트 부호없음: 2^8 = 256 (0 ~ 255)                    │
│   - 8비트 부호있음: -2^7 ~ 2^7-1 (-128 ~ 127)              │
│                                                             │
│   isize/usize: 32비트 시스템에서 32비트,                   │
│                64비트 시스템에서 64비트                     │
│                주로 컬렉션 인덱싱에 사용                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**정수 리터럴 표기법**:

| 리터럴 | 예시 |
|--------|------|
| 10진수 | `98_222` |
| 16진수 | `0xff` |
| 8진수 | `0o77` |
| 2진수 | `0b1111_0000` |
| 바이트 (u8) | `b'A'` |

```rust
let decimal = 98_222;        // 10진수 (언더스코어로 가독성)
let hex = 0xff;              // 16진수
let octal = 0o77;            // 8진수
let binary = 0b1111_0000;    // 2진수
let byte = b'A';             // 바이트 (u8)
```

#### 2. 부동소수점 타입 (Floating-Point)

```
┌─────────────────────────────────────────────────────────────┐
│  부동소수점 타입                                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   f32: 32비트 단정밀도 (약 7자리 정확도)                   │
│   f64: 64비트 배정밀도 (약 15자리 정확도) ← 기본값         │
│                                                             │
│   ┌─────────────────────────────────────────────┐          │
│   │     부호     지수부        가수부           │          │
│   │   ┌─────┐ ┌────────┐ ┌──────────────────┐  │          │
│   │   │  1  │ │   8    │ │       23         │  │ f32     │
│   │   └─────┘ └────────┘ └──────────────────┘  │          │
│   │                                             │          │
│   │   ┌─────┐ ┌────────┐ ┌──────────────────┐  │          │
│   │   │  1  │ │   11   │ │       52         │  │ f64     │
│   │   └─────┘ └────────┘ └──────────────────┘  │          │
│   └─────────────────────────────────────────────┘          │
│                                                             │
│   주의: 부동소수점은 근사값! 정확한 계산에는 부적합         │
│   예: 0.1 + 0.2 = 0.30000000000000004                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

```rust
let x = 2.0;      // f64 (기본)
let y: f32 = 3.0; // f32 (명시)
```

#### 3. 불리언 타입 (Boolean)

```rust
let t = true;
let f: bool = false;
```

- 크기: 1바이트
- 주로 조건문에서 사용

#### 4. 문자 타입 (Character)

```
┌─────────────────────────────────────────────────────────────┐
│  char 타입                                                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   크기: 4바이트 (32비트)                                    │
│   범위: 유니코드 스칼라 값 (U+0000 ~ U+D7FF, U+E000 ~ U+10FFFF) │
│                                                             │
│   ┌─────────────────────────────────────────────┐          │
│   │  'A'      'ㄱ'      '가'      '😀'          │          │
│   │  U+0041   U+3131   U+AC00   U+1F600         │          │
│   │  1바이트  3바이트  3바이트  4바이트 (UTF-8) │          │
│   │  ───────────────────────────────────────    │          │
│   │  모두 char에서는 4바이트로 저장됨           │          │
│   └─────────────────────────────────────────────┘          │
│                                                             │
│   주의: char는 작은따옴표('), 문자열은 큰따옴표(")         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

```rust
let c = 'z';
let korean = '가';
let emoji = '😀';
```

### 복합 타입

#### 1. 튜플 (Tuple)

여러 타입의 값을 하나로 묶는다. 길이 고정.

```
┌─────────────────────────────────────────────────────────────┐
│  튜플 구조                                                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   let tup: (i32, f64, bool) = (500, 6.4, true);            │
│                                                             │
│   메모리 레이아웃:                                          │
│   ┌──────────┬──────────┬──────────┐                       │
│   │ 500      │ 6.4      │ true     │                       │
│   │ (i32)    │ (f64)    │ (bool)   │                       │
│   │ 4바이트  │ 8바이트  │ 1바이트  │                       │
│   └──────────┴──────────┴──────────┘                       │
│   인덱스: .0        .1        .2                            │
│                                                             │
│   접근 방법:                                                │
│   1. 인덱스: tup.0, tup.1, tup.2                           │
│   2. 구조분해: let (x, y, z) = tup;                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

```rust
let tup: (i32, f64, bool) = (500, 6.4, true);

// 구조분해 (destructuring)
let (x, y, z) = tup;

// 인덱스 접근
let first = tup.0;
let second = tup.1;
```

**유닛 타입**: 빈 튜플 `()`은 "유닛"이라고 하며, 값이 없음을 나타낸다.

```rust
let unit: () = ();
// 반환값이 없는 함수는 암묵적으로 ()를 반환
```

#### 2. 배열 (Array)

같은 타입의 값을 묶는다. 길이 고정. 스택에 할당.

```
┌─────────────────────────────────────────────────────────────┐
│  배열 구조                                                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   let arr: [i32; 5] = [1, 2, 3, 4, 5];                     │
│              │    │                                         │
│              │    └── 길이 (컴파일 타임에 고정)            │
│              └── 요소 타입                                  │
│                                                             │
│   메모리 레이아웃 (스택):                                   │
│   ┌─────┬─────┬─────┬─────┬─────┐                          │
│   │  1  │  2  │  3  │  4  │  5  │                          │
│   └─────┴─────┴─────┴─────┴─────┘                          │
│   [0]   [1]   [2]   [3]   [4]                              │
│                                                             │
│   배열 vs Vec<T>:                                          │
│   ┌────────────────┬────────────────┐                      │
│   │ 배열 [T; N]    │ Vec<T>         │                      │
│   ├────────────────┼────────────────┤                      │
│   │ 길이 고정      │ 길이 가변      │                      │
│   │ 스택 할당      │ 힙 할당        │                      │
│   │ 빠름           │ 유연함         │                      │
│   └────────────────┴────────────────┘                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

```rust
// 타입 명시
let arr: [i32; 5] = [1, 2, 3, 4, 5];

// 같은 값으로 초기화
let zeros = [0; 5];  // [0, 0, 0, 0, 0]

// 인덱스 접근
let first = arr[0];
let second = arr[1];
```

**배열 범위 초과 접근**: 컴파일은 되지만 런타임에 패닉 발생

```rust
let arr = [1, 2, 3];
let element = arr[10];  // 런타임 패닉: index out of bounds
```

### 타입 변환

```
┌─────────────────────────────────────────────────────────────┐
│  타입 변환 (as 키워드)                                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Rust는 암묵적 타입 변환을 허용하지 않는다!               │
│   반드시 명시적으로 변환해야 한다.                          │
│                                                             │
│   let x: i32 = 10;                                         │
│   let y: i64 = x;      // 에러! 암묵적 변환 불가           │
│   let y: i64 = x as i64;  // OK! 명시적 변환               │
│                                                             │
│   주의사항:                                                 │
│   - 큰 타입 -> 작은 타입: 값이 잘릴 수 있음                │
│   - 부호 있음 -> 부호 없음: 음수가 이상한 값으로           │
│                                                             │
│   예시:                                                     │
│   let big: i32 = 1000;                                     │
│   let small: u8 = big as u8;  // 232 (1000 % 256)          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 주의사항

1. **정수 오버플로우**
   - Debug 빌드: 패닉 발생
   - Release 빌드: 2의 보수 래핑 (255 + 1 = 0)

2. **부동소수점 비교**
   ```rust
   let x = 0.1 + 0.2;
   if x == 0.3 {  // 위험! 부동소수점은 정확하지 않음
       // ...
   }
   ```

3. **배열 인덱스는 usize**
   ```rust
   let arr = [1, 2, 3];
   let i: i32 = 1;
   let element = arr[i];  // 에러! i32는 인덱스로 사용 불가
   let element = arr[i as usize];  // OK
   ```

---

## 실습

### 실습 1: 정수 타입 탐구

목표: 다양한 정수 타입과 리터럴을 사용한다

코드:
```rust
fn main() {
    // 다양한 정수 타입
    let a: i8 = 127;      // i8 최대값
    let b: u8 = 255;      // u8 최대값
    let c: i32 = 2_147_483_647;  // i32 최대값
    let d: u64 = 18_446_744_073_709_551_615;  // u64 최대값

    println!("i8 최대값: {}", a);
    println!("u8 최대값: {}", b);
    println!("i32 최대값: {}", c);
    println!("u64 최대값: {}", d);

    // 다양한 리터럴 표기법
    let decimal = 1_000_000;
    let hex = 0xDEAD_BEEF;
    let octal = 0o755;
    let binary = 0b1010_1010;
    let byte = b'A';

    println!("\n리터럴 표기:");
    println!("10진수: {}", decimal);
    println!("16진수: {} (0x{:X})", hex, hex);
    println!("8진수: {} (0o{:o})", octal, octal);
    println!("2진수: {} (0b{:b})", binary, binary);
    println!("바이트: {} (문자 'A')", byte);
}
```

실행 결과:
```
i8 최대값: 127
u8 최대값: 255
i32 최대값: 2147483647
u64 최대값: 18446744073709551615

리터럴 표기:
10진수: 1000000
16진수: 3735928559 (0xDEADBEEF)
8진수: 493 (0o755)
2진수: 170 (0b10101010)
바이트: 65 (문자 'A')
```

### 실습 2: 튜플 사용

목표: 튜플을 생성하고 값에 접근한다

코드:
```rust
fn main() {
    // 튜플 생성
    let person: (&str, i32, bool) = ("홍길동", 25, true);

    // 구조분해로 접근
    let (name, age, is_student) = person;
    println!("이름: {}", name);
    println!("나이: {}", age);
    println!("학생 여부: {}", is_student);

    // 인덱스로 접근
    println!("\n인덱스 접근:");
    println!("person.0 = {}", person.0);
    println!("person.1 = {}", person.1);
    println!("person.2 = {}", person.2);

    // 다양한 타입의 튜플
    let mixed = (500, 6.4, true, 'A', "hello");
    println!("\n혼합 튜플: {:?}", mixed);

    // 유닛 타입
    let unit: () = ();
    println!("유닛 타입: {:?}", unit);
}
```

실행 결과:
```
이름: 홍길동
나이: 25
학생 여부: true

인덱스 접근:
person.0 = 홍길동
person.1 = 25
person.2 = true

혼합 튜플: (500, 6.4, true, 'A', "hello")
유닛 타입: ()
```

### 실습 3: 배열 사용

목표: 배열을 생성하고 조작한다

코드:
```rust
fn main() {
    // 배열 생성
    let numbers: [i32; 5] = [1, 2, 3, 4, 5];
    let zeros = [0; 10];  // 0으로 10개 초기화
    let months = ["1월", "2월", "3월", "4월", "5월", "6월",
                  "7월", "8월", "9월", "10월", "11월", "12월"];

    // 인덱스 접근
    println!("첫 번째 숫자: {}", numbers[0]);
    println!("마지막 숫자: {}", numbers[4]);
    println!("3월: {}", months[2]);

    // 배열 길이
    println!("\nnumbers 길이: {}", numbers.len());
    println!("months 길이: {}", months.len());

    // 전체 배열 출력
    println!("\nzeros: {:?}", zeros);
    println!("numbers: {:?}", numbers);

    // 배열 순회 (미리보기 - for 문은 04-control-flow에서 자세히)
    println!("\n배열 순회:");
    for num in numbers {
        print!("{} ", num);
    }
    println!();

    // 가변 배열
    let mut scores = [0; 5];
    scores[0] = 100;
    scores[1] = 90;
    scores[2] = 85;
    println!("\n점수: {:?}", scores);
}
```

실행 결과:
```
첫 번째 숫자: 1
마지막 숫자: 5
3월: 3월

numbers 길이: 5
months 길이: 12

zeros: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
numbers: [1, 2, 3, 4, 5]

배열 순회:
1 2 3 4 5

점수: [100, 90, 85, 0, 0]
```

### 실습 4: 타입 변환

목표: 명시적 타입 변환을 수행한다

코드:
```rust
fn main() {
    // 정수 간 변환
    let small: i8 = 10;
    let big: i64 = small as i64;
    println!("i8 -> i64: {} -> {}", small, big);

    // 주의: 큰 타입에서 작은 타입으로
    let large: i32 = 1000;
    let truncated: u8 = large as u8;  // 1000 % 256 = 232
    println!("i32 -> u8 (잘림): {} -> {}", large, truncated);

    // 부동소수점 <-> 정수
    let float_num: f64 = 3.99;
    let int_num: i32 = float_num as i32;  // 소수점 버림
    println!("f64 -> i32: {} -> {}", float_num, int_num);

    let int_num: i32 = 42;
    let float_num: f64 = int_num as f64;
    println!("i32 -> f64: {} -> {}", int_num, float_num);

    // char <-> 숫자
    let character = 'A';
    let ascii = character as u8;
    println!("char -> u8: '{}' -> {}", character, ascii);

    let code: u8 = 66;
    let character = code as char;
    println!("u8 -> char: {} -> '{}'", code, character);
}
```

실행 결과:
```
i8 -> i64: 10 -> 10
i32 -> u8 (잘림): 1000 -> 232
f64 -> i32: 3.99 -> 3
i32 -> f64: 42 -> 42
char -> u8: 'A' -> 65
u8 -> char: 66 -> 'B'
```

---

## 정리

### 오늘 배운 것
- Rust는 정적 타입 언어로, 모든 변수의 타입이 컴파일 시점에 결정된다
- 스칼라 타입: 정수(i32 기본), 부동소수점(f64 기본), 불리언, 문자
- 복합 타입: 튜플(다른 타입 가능), 배열(같은 타입, 고정 길이)
- `as` 키워드로 명시적 타입 변환 (암묵적 변환 없음)
- 정수 리터럴에 `_` 사용으로 가독성 향상 가능

### 질문/의문점
- isize/usize는 언제 사용하는가?
- 배열 대신 Vec을 언제 사용해야 하는가?
- 정수 오버플로우를 안전하게 처리하는 방법은?

### 추가 학습 필요
- Vec<T> (동적 배열) - 07-collections에서 학습
- 문자열 타입 (String, &str) 심화 - 07-collections에서 학습
- 오버플로우 처리 메서드 (wrapping_add, checked_add 등)

---

## 참고 자료
- The Rust Programming Language - Data Types: https://doc.rust-lang.org/book/ch03-02-data-types.html
- Rust by Example - Primitives: https://doc.rust-lang.org/rust-by-example/primitives.html
- std::primitive: https://doc.rust-lang.org/std/primitive/index.html
