# 변수와 가변성

## 개요

Rust에서 변수를 선언하고 사용하는 방법을 학습한다. Rust는 기본적으로 변수가 불변(immutable)이며, 이는 안전성과 동시성을 위한 핵심 설계이다. 또한 상수, 섀도잉 등 Rust만의 특징적인 개념도 함께 다룬다.

---

## 이론

### 핵심 개념

#### 1. 변수 선언 (let)

```rust
let x = 5;  // 불변 변수
```

Rust에서 변수는 `let` 키워드로 선언한다. 기본적으로 **불변(immutable)**이다.

```
┌─────────────────────────────────────────────────────────────┐
│  왜 기본이 불변인가?                                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 안전성: 의도치 않은 값 변경으로 인한 버그 방지          │
│                                                             │
│  2. 가독성: 변수가 변하지 않음을 보장하므로 코드 추적 쉬움  │
│                                                             │
│  3. 동시성: 여러 스레드가 동시에 읽어도 안전                │
│             (데이터 레이스 방지)                            │
│                                                             │
│  4. 최적화: 컴파일러가 더 공격적인 최적화 가능              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 2. 가변 변수 (mut)

```rust
let mut x = 5;  // 가변 변수
x = 10;         // OK - 값 변경 가능
```

값을 변경해야 할 때는 `mut` 키워드를 사용한다.

```
┌─────────────────────────────────────────────────────────────┐
│  불변 vs 가변 비교                                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   let x = 5;              let mut y = 5;                    │
│   ┌─────────┐             ┌─────────┐                       │
│   │ x = 5   │             │ y = 5   │                       │
│   │ (잠금)  │             │ (열림)  │                       │
│   └─────────┘             └─────────┘                       │
│       │                       │                             │
│       ▼                       ▼                             │
│   x = 10;  ← 컴파일 에러!  y = 10;  ← OK!                   │
│                           ┌─────────┐                       │
│                           │ y = 10  │                       │
│                           └─────────┘                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 3. 상수 (const)

```rust
const MAX_POINTS: u32 = 100_000;
```

상수는 `const` 키워드로 선언하며, 반드시 타입을 명시해야 한다.

```
┌─────────────────────────────────────────────────────────────┐
│  let vs const 차이점                                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│              let                      const                 │
│   ┌─────────────────────┐   ┌─────────────────────┐        │
│   │ mut 사용 가능       │   │ mut 사용 불가       │        │
│   │ 타입 추론 가능      │   │ 타입 명시 필수      │        │
│   │ 런타임에 값 결정 OK │   │ 컴파일 타임에 결정  │        │
│   │ 함수 내부에서만     │   │ 전역 스코프 가능    │        │
│   │ 섀도잉 가능         │   │ 섀도잉 불가         │        │
│   └─────────────────────┘   └─────────────────────┘        │
│                                                             │
│   예시:                                                     │
│   let x = get_value();     // OK - 런타임 값               │
│   const Y: i32 = get_value();  // 에러! 컴파일 타임 필요   │
│   const Z: i32 = 100;      // OK                           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**상수 명명 규칙**: SCREAMING_SNAKE_CASE (대문자 + 언더스코어)

#### 4. 섀도잉 (Shadowing)

```rust
let x = 5;
let x = x + 1;      // 새로운 x가 이전 x를 가림
let x = x * 2;      // 또 다른 새로운 x
println!("{}", x);  // 12
```

같은 이름으로 새 변수를 선언하면 이전 변수를 "가린다".

```
┌─────────────────────────────────────────────────────────────┐
│  섀도잉 동작 원리                                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   let x = 5;          메모리: [x₁ = 5]                      │
│       │                                                     │
│       ▼                                                     │
│   let x = x + 1;      메모리: [x₁ = 5][x₂ = 6]              │
│       │                        (접근불가) (현재)            │
│       ▼                                                     │
│   let x = x * 2;      메모리: [x₁][x₂][x₃ = 12]             │
│                                         (현재)              │
│                                                             │
│   각 let은 새로운 변수를 만든다 (재할당이 아님!)            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**섀도잉 vs mut 재할당**:

```
┌─────────────────────────────────────────────────────────────┐
│  섀도잉 vs 재할당                                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   섀도잉 (let)                  재할당 (mut)                │
│   ─────────────                 ───────────                 │
│   let x = "hello";              let mut x = "hello";        │
│   let x = x.len();  // OK!      x = x.len();  // 에러!      │
│   // x: usize (타입 변경됨)     // 타입이 달라서 불가       │
│                                                             │
│   섀도잉의 장점:                                            │
│   1. 타입을 바꿀 수 있다                                    │
│   2. 변환 후에도 같은 이름 사용 가능                        │
│   3. 불필요하게 mut를 쓰지 않아도 됨                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 문법/사용법

```rust
// 불변 변수
let x = 5;

// 가변 변수
let mut y = 10;
y = 20;

// 타입 명시
let z: i32 = 30;

// 상수 (반드시 타입 명시, 대문자 + 언더스코어)
const MAX_SIZE: usize = 100;

// 섀도잉
let spaces = "   ";
let spaces = spaces.len();  // 타입이 &str에서 usize로 변경

// 숫자 리터럴에 언더스코어 (가독성)
let million = 1_000_000;
```

### 주의사항

1. **불변 변수 재할당 시도는 컴파일 에러**
```rust
let x = 5;
x = 10;  // error[E0384]: cannot assign twice to immutable variable
```

2. **const는 반드시 컴파일 타임 상수**
```rust
const VALUE: i32 = some_function();  // 에러! 런타임 함수 호출 불가
```

3. **섀도잉은 같은 스코프 내에서만**
```rust
let x = 5;
{
    let x = 10;  // 내부 스코프에서 섀도잉
    println!("{}", x);  // 10
}
println!("{}", x);  // 5 (외부 x는 그대로)
```

---

## 실습

### 실습 1: 불변과 가변 변수

목표: 불변 변수와 가변 변수의 차이를 체험한다

코드:
```rust
fn main() {
    // 불변 변수
    let immutable_var = 10;
    println!("불변 변수: {}", immutable_var);

    // 아래 줄의 주석을 해제하면 컴파일 에러 발생
    // immutable_var = 20;  // error[E0384]

    // 가변 변수
    let mut mutable_var = 10;
    println!("가변 변수 (변경 전): {}", mutable_var);

    mutable_var = 20;
    println!("가변 변수 (변경 후): {}", mutable_var);

    // 가변 변수도 여러 번 변경 가능
    mutable_var += 5;
    println!("가변 변수 (추가 변경): {}", mutable_var);
}
```

실행 결과:
```
불변 변수: 10
가변 변수 (변경 전): 10
가변 변수 (변경 후): 20
가변 변수 (추가 변경): 25
```

### 실습 2: 상수 사용

목표: 상수를 선언하고 사용한다

코드:
```rust
// 전역 상수 - 프로그램 전체에서 사용 가능
const PI: f64 = 3.14159265359;
const MAX_USERS: u32 = 100_000;

fn main() {
    // 지역 상수도 가능
    const LOCAL_LIMIT: i32 = 50;

    let radius = 5.0;
    let area = PI * radius * radius;

    println!("원주율: {}", PI);
    println!("반지름 {}인 원의 넓이: {:.2}", radius, area);
    println!("최대 사용자 수: {}", MAX_USERS);
    println!("지역 제한: {}", LOCAL_LIMIT);
}
```

실행 결과:
```
원주율: 3.14159265359
반지름 5인 원의 넓이: 78.54
최대 사용자 수: 100000
지역 제한: 50
```

### 실습 3: 섀도잉 활용

목표: 섀도잉으로 변수를 변환하며 같은 이름을 재사용한다

코드:
```rust
fn main() {
    // 섀도잉으로 값 변환
    let x = 5;
    println!("x = {}", x);

    let x = x + 10;
    println!("x = {} (+ 10)", x);

    let x = x * 2;
    println!("x = {} (* 2)", x);

    // 섀도잉으로 타입 변환
    let input = "   hello   ";
    println!("원본 문자열: '{}'", input);
    println!("원본 타입: &str, 길이: {}", input.len());

    let input = input.trim();  // &str -> &str (공백 제거)
    println!("trim 후: '{}'", input);

    let input = input.len();   // &str -> usize (길이로 변환)
    println!("길이로 변환: {}", input);

    // 스코프와 섀도잉
    let y = 100;
    {
        let y = 200;  // 내부 스코프에서 섀도잉
        println!("내부 스코프 y: {}", y);
    }
    println!("외부 스코프 y: {}", y);  // 원래 y
}
```

실행 결과:
```
x = 5
x = 15 (+ 10)
x = 30 (* 2)
원본 문자열: '   hello   '
원본 타입: &str, 길이: 11
trim 후: 'hello'
길이로 변환: 5
내부 스코프 y: 200
외부 스코프 y: 100
```

### 실습 4: 타입 추론과 명시

목표: Rust의 타입 추론과 명시적 타입 선언을 이해한다

코드:
```rust
fn main() {
    // 타입 추론 - 컴파일러가 타입을 알아냄
    let a = 5;           // i32로 추론
    let b = 3.14;        // f64로 추론
    let c = true;        // bool로 추론
    let d = 'A';         // char로 추론
    let e = "hello";     // &str로 추론

    // 타입 명시
    let f: i64 = 5;      // 명시적으로 i64
    let g: f32 = 3.14;   // 명시적으로 f32

    // 타입 추론이 필요한 경우
    let guess: u32 = "42".parse().expect("숫자가 아닙니다");
    // parse()는 여러 타입을 반환할 수 있어서 타입 명시 필요

    println!("a (i32): {}", a);
    println!("b (f64): {}", b);
    println!("c (bool): {}", c);
    println!("d (char): {}", d);
    println!("e (&str): {}", e);
    println!("f (i64): {}", f);
    println!("g (f32): {}", g);
    println!("guess (u32): {}", guess);
}
```

실행 결과:
```
a (i32): 5
b (f64): 3.14
c (bool): true
d (char): A
e (&str): hello
f (i64): 5
g (f32): 3.14
guess (u32): 42
```

---

## 정리

### 오늘 배운 것
- `let`으로 변수를 선언하며, 기본은 불변(immutable)이다
- `mut` 키워드로 가변 변수를 만들 수 있다
- `const`는 컴파일 타임 상수로, 반드시 타입을 명시해야 한다
- 섀도잉으로 같은 이름의 변수를 재선언할 수 있으며, 타입도 바꿀 수 있다
- Rust는 강력한 타입 추론을 제공하지만, 필요시 명시할 수 있다

### 질문/의문점
- 언제 mut를 쓰고 언제 섀도잉을 쓰는 것이 좋은가?
- static과 const의 차이는 무엇인가?
- 왜 Rust는 기본을 불변으로 설계했는가? (다른 언어와 비교)

### 추가 학습 필요
- static 변수와 생명주기
- 타입 추론의 한계와 터보피시(turbofish) 문법 (`::<Type>`)

---

## 참고 자료
- The Rust Programming Language - Variables and Mutability: https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html
- Rust by Example - Variable Bindings: https://doc.rust-lang.org/rust-by-example/variable_bindings.html
